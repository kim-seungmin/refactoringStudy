
<!-- <br>  &emsp;  &emsp; • -->

|7장|리팩토링 카탈로그|      
|:---|:---|    
|이름|**분류 코드를 클래스 코드로 치환**|    
|상황|객체를 분별하기 위한 분류 코드가 int 같은 기본 타입임|
|문제|타입 판별이 안 됨|
|해법|분류 코드를 나타내는 새로운 클래스를 작성|
|결과|O 분류 코드의 타입 판별이 가능해짐<br> X 클래스 개수가 늘어남|
|방법|**1. 새로운 클래스를 작성해 기존 인터페이스(API)에서 사용** <br> &emsp; (1) 분류 코드를 나타내는 새로운 클래스 작성 <br>  &emsp;  &emsp; • 호환성을 위해 기본 타입을 이용한 인터페이스(API)를 준비함 <br>  &emsp; (2) 기본 타입을 분류 코드로 사용하는 클래스가 새로운 클래스를 사용하도록 변경 <br>  &emsp;  &emsp; •기본 타입을 사용한 기존 인터페이스(API)를 이용 <br>  &emsp;  (3) 컴파일해서 테스트 <br> **2. 새로운 인터페이스(API)로 전환** <br>  &emsp; (1) 기존 타입을 사용하지 않는 새로운 인터페이스(API) 작성 <br>  &emsp;  (2) 기본 타입을 사용한 기존 인터페이스(API)를 새로운 인터페이스 (API)로 치환 <br>  &emsp;  (3) 치환할 때마다 컴파일해서 테스트 <br> **3. 기존 인터페이스(API)삭제** <br>  &emsp; (1) 기존 인터페이스(API)를 사용하는 클래스가 없어지면 기존 인터페이스(API) 삭제 <br>  &emsp;  (2) 컴파일해서 테스트|

|8장|리팩토링 카탈로그|      
|:---|:---|    
|이름|**분류 코드를 하위 클래스로 치환**|    
|상황|분류 코드마다 객체가 다른 동작을 함|
|문제|switch 문을 써서 동작을 구분함|
|해법|분류 코드를 하위 클래스로 치환해서 다형적 메서드를 작성함 |
|결과|O 동작이 클래스별로 나뉨<br> X 클래스 개수가 늘어남|
|방법|**1. 분류 코드에 대응하는 하위 클래스 작성** <br> &emsp; (1) 분류 코드를 자기 캡슐화 <br>  &emsp;  &emsp; • 분류 코드를 나타내는 필드를 직접 보여주는 게 아니라 게터 메서드를 통해 보여주기 <br> &emsp; &emsp; 자기 캡슐화 필드 <br>  &emsp; (2) 분류 코드를 바탕으로 인스턴스를 작성하고 있다면 팩토리 메서드 작성 <br>  &emsp;  &emsp; **생성자를 팩토리 메서드로 치환** <br>  &emsp;  (3) 분류 코드 값마다 하위 클래스 작성 <br>  &emsp;  &emsp; • 하위 클래스에서 분류 코드 게터 메서드를 오버라이드(@Override도 사용) <br>  &emsp;  &emsp; **메서드 내리기** <br>  &emsp;  &emsp; • switch 문에 적힌 동작을 하위 클래스로 이동 <br>  &emsp;  &emsp; **메서드 내리기** <br>  &emsp;  (4) 컴파일해서 테스트 <br> **2. 불필요한 필드 삭제** <br>  &emsp; (1) 분류 코드 필드 삭제 <br>  &emsp;  (2) 기존 클래스의 분류 코드 게터 메서드를 추상 메서드로 만듦 <br>  &emsp;  (3) 컴파일해서 테스트|
