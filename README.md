
<!-- <br>  &emsp;  &emsp; • -->

|7장|리팩토링 카탈로그|      
|:---|:---|    
|이름|**분류 코드를 클래스 코드로 치환**|    
|상황|객체를 분별하기 위한 분류 코드가 int 같은 기본 타입임|
|문제|타입 판별이 안 됨|
|해법|분류 코드를 나타내는 새로운 클래스를 작성|
|결과|O 분류 코드의 타입 판별이 가능해짐<br> X 클래스 개수가 늘어남|
|방법|**1. 새로운 클래스를 작성해 기존 인터페이스(API)에서 사용** <br> &emsp; (1) 분류 코드를 나타내는 새로운 클래스 작성 <br>  &emsp;  &emsp; • 호환성을 위해 기본 타입을 이용한 인터페이스(API)를 준비함 <br>  &emsp; (2) 기본 타입을 분류 코드로 사용하는 클래스가 새로운 클래스를 사용하도록 변경 <br>  &emsp;  &emsp; •기본 타입을 사용한 기존 인터페이스(API)를 이용 <br>  &emsp;  (3) 컴파일해서 테스트 <br> **2. 새로운 인터페이스(API)로 전환** <br>  &emsp; (1) 기존 타입을 사용하지 않는 새로운 인터페이스(API) 작성 <br>  &emsp;  (2) 기본 타입을 사용한 기존 인터페이스(API)를 새로운 인터페이스 (API)로 치환 <br>  &emsp;  (3) 치환할 때마다 컴파일해서 테스트 <br> **3. 기존 인터페이스(API)삭제** <br>  &emsp; (1) 기존 인터페이스(API)를 사용하는 클래스가 없어지면 기존 인터페이스(API) 삭제 <br>  &emsp;  (2) 컴파일해서 테스트|

|8장|리팩토링 카탈로그|      
|:---|:---|    
|이름|**분류 코드를 하위 클래스로 치환**|    
|상황|분류 코드마다 객체가 다른 동작을 함|
|문제|switch 문을 써서 동작을 구분함|
|해법|분류 코드를 하위 클래스로 치환해서 다형적 메서드를 작성함 |
|결과|O 동작이 클래스별로 나뉨<br> X 클래스 개수가 늘어남|
|방법|**1. 분류 코드에 대응하는 하위 클래스 작성** <br> &emsp; (1) 분류 코드를 자기 캡슐화 <br>  &emsp;  &emsp; • 분류 코드를 나타내는 필드를 직접 보여주는 게 아니라 게터 메서드를 통해 보여주기 <br> &emsp; &emsp; 자기 캡슐화 필드 <br>  &emsp; (2) 분류 코드를 바탕으로 인스턴스를 작성하고 있다면 팩토리 메서드 작성 <br>  &emsp;  &emsp; **생성자를 팩토리 메서드로 치환** <br>  &emsp;  (3) 분류 코드 값마다 하위 클래스 작성 <br>  &emsp;  &emsp; • 하위 클래스에서 분류 코드 게터 메서드를 오버라이드(@Override도 사용) <br>  &emsp;  &emsp; **메서드 내리기** <br>  &emsp;  &emsp; • switch 문에 적힌 동작을 하위 클래스로 이동 <br>  &emsp;  &emsp; **메서드 내리기** <br>  &emsp;  (4) 컴파일해서 테스트 <br> **2. 불필요한 필드 삭제** <br>  &emsp; (1) 분류 코드 필드 삭제 <br>  &emsp;  (2) 기존 클래스의 분류 코드 게터 메서드를 추상 메서드로 만듦 <br>  &emsp;  (3) 컴파일해서 테스트|

|9장|리팩토링 카탈로그|      
|:---|:---|    
|이름|**분류 코드를 상태/전략 패턴으로 치환**|    
|상황|객체가 다른 동작을함|
|문제|switch 문을 써서 동작을 구분함|
|해법|코드를나타내는새로운 클래스를 작성해서 상태/전략 패턴을 사용함|
|결과|O 분류 코드 타입 판별이 가능함<br>O 분류코드에 따른 클래스 동작을 다형성으로 해결 가능 <br>X 클래스 개수가 늘어남|
|방법|**1. 상태 객체를 나타내는 클래스 작성** <br> &emsp; (1) 분류 코드를 자기 캡슐화 <br>  &emsp;  (2) 분류코드를 나타내는 새로운 클래스(상태 클래스) 작성 <br>  &emsp;  (3) 분류 코드 값마다 상태 객체의 하위 클래스 작성 <br>  &emsp;  (4) 분류 코드를 얻는 추상메서드를 상태 객체에 작성 <br>  &emsp;  (5) 하위 클래스는 추상 메서드를 오버라이드해서 분류 코드를 반환 <br>  &emsp;  (6) 컴파일 <br>  **2. 상태 객체 사용** <br>  &emsp;  (1) 분류 코드를 사용하는 클래스에 상태 객체용 필드 추가 <br>  &emsp;  (2) 분류 코드를 조사하는 코드를 분류 코드를 얻는 메서드 호출로 치환 <br>  &emsp;  (3) 분류 코드를 변경하는 코드를 상태 객체를 변경하는 코드로 치환 <br>  &emsp;  (4) 컴파일 해서 테스트|

|10장|리팩토링 카탈로그|      
|:---|:---|    
|이름|**에러 코드를 예외로 치환**|    
|상황|에러 발생 사실을 에러 코드로 표현함|
|문제|정상 처리와 에러 처리가 혼재함 <br> 에러 코드가 전파 처리가 넓은 범위에 있음|
|해법|에러 코드 대신에 예외를 사용함|
|결과|O 정상 처리와 에러 처리를 명확하게 분리 가능 <br>O 에러 코드를 반환해서 전파하지 않아도됨 <br>O 에러 관련 정보를 예외 객체에 저장 가능 <br>X 에러 발생 부분과 에러 처리 부분이 분리되기 때문에 알기 어려워지는 경우도 있음|
|방법|**1. 에러 종류에 맞는 적절한 예외 작성** <br>  &emsp; (1) 예외 상태가 아니라면 예외를 사용하지 않음 <br>  &emsp; (2) 복구 가능한 에러라면 검사 예외 선택 <br>  &emsp; (3) 복구 불가능한 에러 또는 프로그래머 실수로 인한 에러라면 비검사 예외 선택 <br>  &emsp; (4) 컴파일 <br> **2. 메서드를 호출하는 쪽 변경(검사 예외)** <br>  &emsp; (1) 호출하는 쪽에서 에러를 처리한다면 try~catch 추가 <br>  &emsp; (2) 호출하는 쪽에서 에러를 처리하지 않는다면 throws 절 추가 <br>  &emsp; (3) 컴파일 해서 테스트 <br>**3. 메서드를 호출하는 쪽 변경(비검사 예외)** <br>  &emsp; (1) 호출하기 전에 조건 판정 <br>  &emsp; (2) 컴파일해서 테스트|
