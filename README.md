
<!-- <br>  &emsp;  &emsp; • -->

   
   
|7장|**분류 코드를 클래스 코드로 치환**|    
|:---|:---| 
|상황|객체를 분별하기 위한 분류 코드가 int 같은 기본 타입임|
|문제|타입 판별이 안 됨|
|해법|분류 코드를 나타내는 새로운 클래스를 작성|
|결과|O 분류 코드의 타입 판별이 가능해짐<br> X 클래스 개수가 늘어남|
|방법|**1. 새로운 클래스를 작성해 기존 인터페이스(API)에서 사용** <br> &emsp; (1) 분류 코드를 나타내는 새로운 클래스 작성 <br>  &emsp;  &emsp; • 호환성을 위해 기본 타입을 이용한 인터페이스(API)를 준비함 <br>  &emsp; (2) 기본 타입을 분류 코드로 사용하는 클래스가 새로운 클래스를 사용하도록 변경 <br>  &emsp;  &emsp; •기본 타입을 사용한 기존 인터페이스(API)를 이용 <br>  &emsp;  (3) 컴파일해서 테스트 <br> **2. 새로운 인터페이스(API)로 전환** <br>  &emsp; (1) 기존 타입을 사용하지 않는 새로운 인터페이스(API) 작성 <br>  &emsp;  (2) 기본 타입을 사용한 기존 인터페이스(API)를 새로운 인터페이스 (API)로 치환 <br>  &emsp;  (3) 치환할 때마다 컴파일해서 테스트 <br> **3. 기존 인터페이스(API)삭제** <br>  &emsp; (1) 기존 인터페이스(API)를 사용하는 클래스가 없어지면 기존 인터페이스(API) 삭제 <br>  &emsp;  (2) 컴파일해서 테스트|

|8장|**분류 코드를 하위 클래스로 치환**|      
|:---|:---|    
|상황|분류 코드마다 객체가 다른 동작을 함|
|문제|switch 문을 써서 동작을 구분함|
|해법|분류 코드를 하위 클래스로 치환해서 다형적 메서드를 작성함 |
|결과|O 동작이 클래스별로 나뉨<br> X 클래스 개수가 늘어남|
|방법|**1. 분류 코드에 대응하는 하위 클래스 작성** <br> &emsp; (1) 분류 코드를 자기 캡슐화 <br>  &emsp;  &emsp; • 분류 코드를 나타내는 필드를 직접 보여주는 게 아니라 게터 메서드를 통해 보여주기 <br> &emsp; &emsp; 자기 캡슐화 필드 <br>  &emsp; (2) 분류 코드를 바탕으로 인스턴스를 작성하고 있다면 팩토리 메서드 작성 <br>  &emsp;  &emsp; **생성자를 팩토리 메서드로 치환** <br>  &emsp;  (3) 분류 코드 값마다 하위 클래스 작성 <br>  &emsp;  &emsp; • 하위 클래스에서 분류 코드 게터 메서드를 오버라이드(@Override도 사용) <br>  &emsp;  &emsp; **메서드 내리기** <br>  &emsp;  &emsp; • switch 문에 적힌 동작을 하위 클래스로 이동 <br>  &emsp;  &emsp; **메서드 내리기** <br>  &emsp;  (4) 컴파일해서 테스트 <br> **2. 불필요한 필드 삭제** <br>  &emsp; (1) 분류 코드 필드 삭제 <br>  &emsp;  (2) 기존 클래스의 분류 코드 게터 메서드를 추상 메서드로 만듦 <br>  &emsp;  (3) 컴파일해서 테스트|

|9장|**분류 코드를 상태/전략 패턴으로 치환**|      
|:---|:---|    
|상황|객체가 다른 동작을함|
|문제|switch 문을 써서 동작을 구분함|
|해법|코드를나타내는새로운 클래스를 작성해서 상태/전략 패턴을 사용함|
|결과|O 분류 코드 타입 판별이 가능함<br>O 분류코드에 따른 클래스 동작을 다형성으로 해결 가능 <br>X 클래스 개수가 늘어남|
|방법|**1. 상태 객체를 나타내는 클래스 작성** <br> &emsp; (1) 분류 코드를 자기 캡슐화 <br>  &emsp;  (2) 분류코드를 나타내는 새로운 클래스(상태 클래스) 작성 <br>  &emsp;  (3) 분류 코드 값마다 상태 객체의 하위 클래스 작성 <br>  &emsp;  (4) 분류 코드를 얻는 추상메서드를 상태 객체에 작성 <br>  &emsp;  (5) 하위 클래스는 추상 메서드를 오버라이드해서 분류 코드를 반환 <br>  &emsp;  (6) 컴파일 <br>  **2. 상태 객체 사용** <br>  &emsp;  (1) 분류 코드를 사용하는 클래스에 상태 객체용 필드 추가 <br>  &emsp;  (2) 분류 코드를 조사하는 코드를 분류 코드를 얻는 메서드 호출로 치환 <br>  &emsp;  (3) 분류 코드를 변경하는 코드를 상태 객체를 변경하는 코드로 치환 <br>  &emsp;  (4) 컴파일 해서 테스트|

|10장|**에러 코드를 예외로 치환**|      
|:---|:---|    
|상황|에러 발생 사실을 에러 코드로 표현함|
|문제|정상 처리와 에러 처리가 혼재함 <br> 에러 코드가 전파 처리가 넓은 범위에 있음|
|해법|에러 코드 대신에 예외를 사용함|
|결과|O 정상 처리와 에러 처리를 명확하게 분리 가능 <br>O 에러 코드를 반환해서 전파하지 않아도됨 <br>O 에러 관련 정보를 예외 객체에 저장 가능 <br>X 에러 발생 부분과 에러 처리 부분이 분리되기 때문에 알기 어려워지는 경우도 있음|
|방법|**1. 에러 종류에 맞는 적절한 예외 작성** <br>  &emsp; (1) 예외 상태가 아니라면 예외를 사용하지 않음 <br>  &emsp; (2) 복구 가능한 에러라면 검사 예외 선택 <br>  &emsp; (3) 복구 불가능한 에러 또는 프로그래머 실수로 인한 에러라면 비검사 예외 선택 <br>  &emsp; (4) 컴파일 <br> **2. 메서드를 호출하는 쪽 변경(검사 예외)** <br>  &emsp; (1) 호출하는 쪽에서 에러를 처리한다면 try~catch 추가 <br>  &emsp; (2) 호출하는 쪽에서 에러를 처리하지 않는다면 throws 절 추가 <br>  &emsp; (3) 컴파일 해서 테스트 <br>**3. 메서드를 호출하는 쪽 변경(비검사 예외)** <br>  &emsp; (1) 호출하기 전에 조건 판정 <br>  &emsp; (2) 컴파일해서 테스트|

|11장|**생성자를 팩토리 메서드로 치환**|      
|:---|:---|    
|상황|인스턴스를 생성함|
|문제|생성하고 싶은 인스턴스가 속한 실제 클래스를 클라이언트에는 숨기고 싶음|
|해법|생성자를 팩토리 메서드로 치환함|
|결과|O 어느 클래스 인스턴스를 생성할지를 팩토리 메서드 안에서 정할 수 있음 <br>O 생성한 인스턴스를 변경해도 클라이언트 쪽은 변경하지 않아도 됨 <br>X 추상도가 너무 올라가면 코드가 오히려 어려워짐|
|방법|**1. 팩토리 메서드 작성** <br>  &emsp; (1) 팩토리 메서드 작성 <br>  &emsp; 팩토리 메서드 안에서는 현재 생성자를 호출 <br>  &emsp; (2) 팩토리 메서드 호출 <br>  &emsp; 클라이언트에서 생성자를 호출하는 부분을 수정해서 팩토리 메서드를 호출하도록 함 <br>  &emsp; (3) 컴파일해서 테스트 <br> **2. 생성자 숨기기** <br>  &emsp; (1) 생성자를 private로 만듦 <br>  &emsp; 그러면 생성자를 클라이언트에서 실수로 호출하는 걸 막을 수 있어서 팩토리 메서드 호출이 보장됨 <br>  &emsp; (2) 컴파일|

|12장|**관측 데이터 복재**|      
|:---|:---|    
|상황|데이터를 표시하는 클래스가 있음|
|문제|모델과 뷰가 한 클래스 안에 뒤섞여 있음|
|해법|양쪽을 분리하고 관찰자 패턴 또는 이벤트 리스너로 동기화함|
|결과|O 클래스 역할이 확실해짐 <br>O 여러 뷰를 가지거나 뷰를 전환하기 쉬워짐 <br>X 클래스 숫자가 늘어남 <br>X 주의하지 않으면 동기화 이벤트가 무한히 발생할 수도 있음|
|방법|**1. 모델을 나타내는 클래스 작성** <br>  &emsp; (1) 팩토리 메서드 작성 <br>  &emsp; **클래스 추출** <br>  &emsp; (2) 뷰: 뷰에서 모델 참조<br>  &emsp; (3) 뷰: 모델을 메서드로 조작 <br>  &emsp; (4) 컴파일해서 테스트 <br>**2. 통지 관련 클래스와 인터페이스 작성** <br>  &emsp; (1) 통지 내용을 낱타내는 이벤트 선언 <br>  &emsp; (2) 통지 관련 인터페이스 선언 <br>  &emsp; (3) 통지를 받는 메서드를 뷰에 선언 <br>  &emsp; (4) 컴파일해서 테스트 <br>**3. 뷰 등록과 뷰 통지** <br>  &emsp; (1) 모델: 뷰를 모델에 등록 가능하게 만듦 <br>  &emsp; (2) 뷰: 뷰를 모델에 등록 <br>  &emsp; (3) 모델: '모델을 변경하면 뷰에 통지'하는 코드 작성 <br>  &emsp; (4) 뷰: 통지를 받는 메서드 안으로 표시 갱신 처리를 이동 <br>  &emsp; (5) 컴파일해서 테스트|

|13장|**상속을 위임으로 치환**|      
|:---|:---|    
|상황|클래스에 상속 관계가 있음|
|문제|• 하위 클래스가 상위 클래스 기능의 일부분만<br> •하위 클래스가 상속 클래스와 IS-A 관계가 아님 <br>• 리스코프 치환 원칙 위반 <br>• 계약을 지키지 않음 |
|해법|위임을 사용해서 상속을 치환함|
|결과|O 부적절한 상속 관계를 해소 가능함 <br>O 클래스에 필요한 기능이 명확해짐 <br>O 클래스 개선, 기능 추가가 편해짐 <br>X 위임하는 메서드를 작성해야 함|
|방법|**1. 위임용 필드 도입** <br>  &emsp; (1) 하위 클래스에 상위 클래스 타입의 위임용 필드 선언 <br>  &emsp; (2) 생성자 안에서 위임용 필드를 this로 초기화 <br>  &emsp; (3) 상속받던 메서드를 재작성해서 위임용 필드를 이용하게 함 <br>  &emsp; (4) 컴파일해서 테스트 <br>  **2. 상속 관계 삭제** <br>  &emsp; (1) 상속 클래스 선언(extends) 삭제 <br>  &emsp; (2) 위임용 필드를 상위 클래스의 인스턴스로 초기화 <br>  &emsp; (3) 지금까지 외부에서 암묵적으로 이용하던 메서드를 명시적으로 선언 <br>  &emsp; (4) 그 메서드를 위임용 필드 경유 호출로 작성 <br>  &emsp; (5) 컴파일해서 테스트|

|14장|**대리자 은폐**|      
|:---|:---|    
|상황|클래스에 위임 관계가 있음|
|문제|클라이언트 클래스가 서버 클래스뿐만 아니라 대리 클래스까지 이용함 |
|해법|서버 클래스에 위임 메서드를 추가해서 클라이언트 클래스로부터 대리 클래스를 은폐|
|결과|O 클래스 사이의 불필요한 관계가 줄고 코드 수정이 쉬워짐 <br>X 서버 클래스의 책임이 늘어남|
|방법|**1. 위임용 메서드 작성** <br>  &emsp; (1) 대리 클래스의 메서드에 대응하는 위임 메서드를 서버 클래스에 작성 <br>  &emsp; (2) 클라이언트 클래스는 대리 클래스가 아닌 서버 클래스를 호출하도록 변경 <br>  &emsp; (3) 컴파일해서 테스트 <br>  **2. 대리 클래스 은폐** <br>  &emsp; (1) 서버 클래스에 있는 대리 클래스의 게터 메서드 삭제 (2) 컴파일 해서 테스트|

|15장|**상속 구조 정리**|      
|:---|:---|    
|상황|클래스 계층 하나에 많은 클래스가 존재함|
|문제|클래스 계층 하나에서 다양한 작업을 함|
|해법|상속을 분할하고 필요한 작업은 위임을 사용해 이용함|
|결과|O 부적절한 상속 관계를 해소 가능 <br>O 클래스 개선, 기능 추가가 편해짐 <br>X 클래스 개수가 늘기도 함|
|방법|**1. 어떤 작업을 이동할지 결정** <br>  &emsp; (1) 기존 클래스 계층에서 하던 작업 나열 <br>  &emsp; (2) 이동할 작업 판단 <br>  **2. 위임 처리** <br>  &emsp; (1) 이동할 작업을 나타내는 클래스를 새로 작성 <br>  &emsp; (2) 기존 클래스 계층에서 클래스 추출 <br>  &emsp; (3) 위임할 필드 작성 <br> **3. 새로운 상속 구성** <br>  &emsp; (1) 기존 클래스 계층의 하위 클래스에 대응하는 새로운 클래스의 하위 클래스 작성 <br>  &emsp; (2) 기존 하위 클래스에서 새로운 하위 클래스로 메서드 이동 <br>**4. 추가 리팩토링** <br>  &emsp; (1) 하위 클래스에 메서드가 남아 있지 않다면 하위 클래스 삭제 <br>  &emsp; (2) 메서드 올리기 또는 메서드 내리기 |
