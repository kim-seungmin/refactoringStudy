
<!-- <br>  &emsp;  &emsp; • -->

|7장|리팩토링 카탈로그|      
|:---|:---|    
|이름|**분류 코드를 클래스 코드로 치환**|    
|상황|객체를 분별하기 위한 분류 코드가 int 같은 기본 타입임|
|문제|타입 판별이 안 됨|
|해법|분류 코드를 나타내는 새로운 클래스를 작성|
|결과|O 분류 코드의 타입 판별이 가능해짐<br> X 클래스 개수가 늘어남|
|방법|**1. 새로운 클래스를 작성해 기존 인터페이스(API)에서 사용** <br> &emsp; (1) 분류 코드를 나타내는 새로운 클래스 작성 <br>  &emsp;  &emsp; • 호환성을 위해 기본 타입을 이용한 인터페이스(API)를 준비함 <br>  &emsp; (2) 기본 타입을 분류 코드로 사용하는 클래스가 새로운 클래스를 사용하도록 변경 <br>  &emsp;  &emsp; •기본 타입을 사용한 기존 인터페이스(API)를 이용 <br>  &emsp;  (3) 컴파일해서 테스트 <br> **2. 새로운 인터페이스(API)로 전환** <br>  &emsp; (1) 기존 타입을 사용하지 않는 새로운 인터페이스(API) 작성 <br>  &emsp;  (2) 기본 타입을 사용한 기존 인터페이스(API)를 새로운 인터페이스 (API)로 치환 <br>  &emsp;  (3) 치환할 때마다 컴파일해서 테스트 <br> **3. 기존 인터페이스(API)삭제** <br>  &emsp; (1) 기존 인터페이스(API)를 사용하는 클래스가 없어지면 기존 인터페이스(API) 삭제 <br>  &emsp;  (2) 컴파일해서 테스트|

|8장|리팩토링 카탈로그|      
|:---|:---|    
|이름|**분류 코드를 하위 클래스로 치환**|    
|상황|분류 코드마다 객체가 다른 동작을 함|
|문제|switch 문을 써서 동작을 구분함|
|해법|분류 코드를 하위 클래스로 치환해서 다형적 메서드를 작성함 |
|결과|O 동작이 클래스별로 나뉨<br> X 클래스 개수가 늘어남|
|방법|**1. 분류 코드에 대응하는 하위 클래스 작성** <br> &emsp; (1) 분류 코드를 자기 캡슐화 <br>  &emsp;  &emsp; • 분류 코드를 나타내는 필드를 직접 보여주는 게 아니라 게터 메서드를 통해 보여주기 <br> &emsp; &emsp; 자기 캡슐화 필드 <br>  &emsp; (2) 분류 코드를 바탕으로 인스턴스를 작성하고 있다면 팩토리 메서드 작성 <br>  &emsp;  &emsp; **생성자를 팩토리 메서드로 치환** <br>  &emsp;  (3) 분류 코드 값마다 하위 클래스 작성 <br>  &emsp;  &emsp; • 하위 클래스에서 분류 코드 게터 메서드를 오버라이드(@Override도 사용) <br>  &emsp;  &emsp; **메서드 내리기** <br>  &emsp;  &emsp; • switch 문에 적힌 동작을 하위 클래스로 이동 <br>  &emsp;  &emsp; **메서드 내리기** <br>  &emsp;  (4) 컴파일해서 테스트 <br> **2. 불필요한 필드 삭제** <br>  &emsp; (1) 분류 코드 필드 삭제 <br>  &emsp;  (2) 기존 클래스의 분류 코드 게터 메서드를 추상 메서드로 만듦 <br>  &emsp;  (3) 컴파일해서 테스트|

|9장|리팩토링 카탈로그|      
|:---|:---|    
|이름|**분류 코드를 상태/전략 패턴으로 치환**|    
|상황|객체가 다른 동작을함|
|문제|switch 문을 써서 동작을 구분함|
|해법|코드를나타내는새로운 클래스를 작성해서 상태/전략 패턴을 사용함|
|결과|O 분류 코드 타입 판별이 가능함<br>O 분류코드에 따른 클래스 동작을 다형성으로 해결 가능 <br>X 클래스 개수가 늘어남|
|방법|**1. 상태 객체를 나타내는 클래스 작성** <br> &emsp; (1) 분류 코드를 자기 캡슐화 <br>  &emsp;  (2) 분류코드를 나타내는 새로운 클래스(상태 클래스) 작성 <br>  &emsp;  (3) 분류 코드 값마다 상태 객체의 하위 클래스 작성 <br>  &emsp;  (4) 분류 코드를 얻는 추상메서드를 상태 객체에 작성 <br>  &emsp;  (5) 하위 클래스는 추상 메서드를 오버라이드해서 분류 코드를 반환 <br>  &emsp;  (6) 컴파일 <br>  **2. 상태 객체 사용** <br>  &emsp;  (1) 분류 코드를 사용하는 클래스에 상태 객체용 필드 추가 <br>  &emsp;  (2) 분류 코드를 조사하는 코드를 분류 코드를 얻는 메서드 호출로 치환 <br>  &emsp;  (3) 분류 코드를 변경하는 코드를 상태 객체를 변경하는 코드로 치환 <br>  &emsp;  (4) 컴파일 해서 테스트|

|10장|리팩토링 카탈로그|      
|:---|:---|    
|이름|**에러 코드를 예외로 치환**|    
|상황|에러 발생 사실을 에러 코드로 표현함|
|문제|정상 처리와 에러 처리가 혼재함 <br> 에러 코드가 전파 처리가 넓은 범위에 있음|
|해법|에러 코드 대신에 예외를 사용함|
|결과|O 정상 처리와 에러 처리를 명확하게 분리 가능 <br>O 에러 코드를 반환해서 전파하지 않아도됨 <br>O 에러 관련 정보를 예외 객체에 저장 가능 <br>X 에러 발생 부분과 에러 처리 부분이 분리되기 때문에 알기 어려워지는 경우도 있음|
|방법|**1. 에러 종류에 맞는 적절한 예외 작성** <br>  &emsp; (1) 예외 상태가 아니라면 예외를 사용하지 않음 <br>  &emsp; (2) 복구 가능한 에러라면 검사 예외 선택 <br>  &emsp; (3) 복구 불가능한 에러 또는 프로그래머 실수로 인한 에러라면 비검사 예외 선택 <br>  &emsp; (4) 컴파일 <br> **2. 메서드를 호출하는 쪽 변경(검사 예외)** <br>  &emsp; (1) 호출하는 쪽에서 에러를 처리한다면 try~catch 추가 <br>  &emsp; (2) 호출하는 쪽에서 에러를 처리하지 않는다면 throws 절 추가 <br>  &emsp; (3) 컴파일 해서 테스트 <br>**3. 메서드를 호출하는 쪽 변경(비검사 예외)** <br>  &emsp; (1) 호출하기 전에 조건 판정 <br>  &emsp; (2) 컴파일해서 테스트|

|11장|리팩토링 카탈로그|      
|:---|:---|    
|이름|**생성자를 팩토리 메서드로 치환**|    
|상황|인스턴스를 생성함|
|문제|생성하고 싶은 인스턴스가 속한 실제 클래스를 클라이언트에는 숨기고 싶음|
|해법|생성자를 팩토리 메서드로 치환함|
|결과|O 어느 클래스 인스턴스를 생성할지를 팩토리 메서드 안에서 정할 수 있음 <br>O 생성한 인스턴스를 변경해도 클라이언트 쪽은 변경하지 않아도 됨 <br>X 추상도가 너무 올라가면 코드가 오히려 어려워짐|
|방법|**1. 팩토리 메서드 작성** <br>  &emsp; (1) 팩토리 메서드 작성 <br>  &emsp; 팩토리 메서드 안에서는 현재 생성자를 호출 <br>  &emsp; (2) 팩토리 메서드 호출 <br>  &emsp; 클라이언트에서 생성자를 호출하는 부분을 수정해서 팩토리 메서드를 호출하도록 함 <br>  &emsp; (3) 컴파일해서 테스트 <br> **2. 생성자 숨기기** <br>  &emsp; (1) 생성자를 private로 만듦 <br>  &emsp; 그러면 생성자를 클라이언트에서 실수로 호출하는 걸 막을 수 있어서 팩토리 메서드 호출이 보장됨 <br>  &emsp; (2) 컴파일|

|12장|리팩토링 카탈로그|      
|:---|:---|    
|이름|**관측 데이터 복재**|    
|상황|데이터를 표시하는 클래스가 있음|
|문제|모델과 뷰가 한 클래스 안에 뒤섞여 있음|
|해법|양쪽을 분리하고 관찰자 패턴 또는 이벤트 리스너로 동기화함|
|결과|O 클래스 역할이 확실해짐 <br>O 여러 뷰를 가지거나 뷰를 전환하기 쉬워짐 <br>X 클래스 숫자가 늘어남 <br>X 주의하지 않으면 동기화 이벤트가 무한히 발생할 수도 있음|
|방법|**1. 모델을 나타내는 클래스 작성** <br>  &emsp; (1) 팩토리 메서드 작성 <br>  &emsp; **클래스 추출** <br>  &emsp; (2) 뷰: 뷰에서 모델 참조<br>  &emsp; (3) 뷰: 모델을 메서드로 조작 <br>  &emsp; (4) 컴파일해서 테스트 <br>**2. 통지 관련 클래스와 인터페이스 작성** <br>  &emsp; (1) 통지 내용을 낱타내는 이벤트 선언 <br>  &emsp; (2) 통지 관련 인터페이스 선언 <br>  &emsp; (3) 통지를 받는 메서드를 뷰에 선언 <br>  &emsp; (4) 컴파일해서 테스트 <br>**3. 뷰 등록과 뷰 통지** <br>  &emsp; (1) 모델: 뷰를 모델에 등록 가능하게 만듦 <br>  &emsp; (2) 뷰: 뷰를 모델에 등록 <br>  &emsp; (3) 모델: '모델을 변경하면 뷰에 통지'하는 코드 작성 <br>  &emsp; (4) 뷰: 통지를 받는 메서드 안으로 표시 갱신 처리를 이동 <br>  &emsp; (5) 컴파일해서 테스트|
